Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> start
Rule 1     start -> INSTRUCTIONS
Rule 2     INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION
Rule 3     INSTRUCTIONS -> INSTRUCTION
Rule 4     INSTRUCTION -> STATEMENT ;
Rule 5     INSTRUCTION -> BLOCK_STATEMENT
Rule 6     INSTRUCTION -> IF_STATEMENT
Rule 7     INSTRUCTION -> WHILE_STATEMENT
Rule 8     INSTRUCTION -> FOR_STATEMENT
Rule 9     STATEMENT -> ASSIGNMENT
Rule 10    STATEMENT -> KEYWORD
Rule 11    ASSIGNMENT -> LEFT_ASSIGNMENT = EXPRESSION
Rule 12    ASSIGNMENT -> LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
Rule 13    ASSIGNMENT -> LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
Rule 14    ASSIGNMENT -> LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
Rule 15    ASSIGNMENT -> LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
Rule 16    LEFT_ASSIGNMENT -> CONST_ID
Rule 17    LEFT_ASSIGNMENT -> ACCESS
Rule 18    ACCESS -> CONST_ID [ SEQUENCE ]
Rule 19    SEQUENCE -> SEQUENCE , EXPRESSION
Rule 20    SEQUENCE -> EXPRESSION
Rule 21    VALUE -> CONST_VALUE
Rule 22    VALUE -> MATRIX
Rule 23    VALUE -> ACCESS
Rule 24    VALUE -> CONST_ID
Rule 25    CONST_VALUE -> FLOAT
Rule 26    CONST_VALUE -> INT
Rule 27    CONST_VALUE -> STRING
Rule 28    CONST_ID -> ID
Rule 29    MATRIX -> [ ROWS ]
Rule 30    ROWS -> ROWS ; SEQUENCE
Rule 31    ROWS -> SEQUENCE
Rule 32    EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION
Rule 33    EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION
Rule 34    EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION
Rule 35    EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION
Rule 36    EXPRESSION -> EXPRESSION + EXPRESSION
Rule 37    EXPRESSION -> EXPRESSION - EXPRESSION
Rule 38    EXPRESSION -> EXPRESSION * EXPRESSION
Rule 39    EXPRESSION -> EXPRESSION / EXPRESSION
Rule 40    EXPRESSION -> EYE ( EXPRESSION )
Rule 41    EXPRESSION -> ZEROS ( EXPRESSION )
Rule 42    EXPRESSION -> ONES ( EXPRESSION )
Rule 43    EXPRESSION -> EXPRESSION '
Rule 44    EXPRESSION -> VALUE
Rule 45    EXPRESSION -> ( EXPRESSION )
Rule 46    EXPRESSION -> - EXPRESSION
Rule 47    KEYWORD -> PRINT SEQUENCE
Rule 48    KEYWORD -> BREAK
Rule 49    KEYWORD -> CONTINUE
Rule 50    KEYWORD -> RETURN EXPRESSION
Rule 51    CONDITION -> EXPRESSION < EXPRESSION
Rule 52    CONDITION -> EXPRESSION > EXPRESSION
Rule 53    CONDITION -> EXPRESSION EQ EXPRESSION
Rule 54    CONDITION -> EXPRESSION NEQ EXPRESSION
Rule 55    CONDITION -> EXPRESSION GEQ EXPRESSION
Rule 56    CONDITION -> EXPRESSION LEQ EXPRESSION
Rule 57    BLOCK_STATEMENT -> { INSTRUCTIONS }
Rule 58    IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION
Rule 59    IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
Rule 60    WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION
Rule 61    FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION
Rule 62    RANGE -> EXPRESSION : EXPRESSION
Rule 63    RANGE -> EXPRESSION : EXPRESSION : EXPRESSION

Terminals, with rules where they appear

'                    : 43
(                    : 40 41 42 45 58 59 60
)                    : 40 41 42 45 58 59 60
*                    : 38
+                    : 36
,                    : 19
-                    : 37 46
/                    : 39
:                    : 62 63 63
;                    : 4 30
<                    : 51
=                    : 11 61
>                    : 52
BREAK                : 48
CONTINUE             : 49
DIV_ASSIGN           : 15
DOT_DIV              : 35
DOT_MINUS            : 33
DOT_MUL              : 34
DOT_PLUS             : 32
ELSE                 : 59
EQ                   : 53
EYE                  : 40
FLOAT                : 25
FOR                  : 61
GEQ                  : 55
ID                   : 28
IF                   : 58 59
INT                  : 26
LEQ                  : 56
MINUS_ASSIGN         : 13
MUL_ASSIGN           : 14
NEQ                  : 54
ONES                 : 42
PLUS_ASSIGN          : 12
PRINT                : 47
RETURN               : 50
STRING               : 27
WHILE                : 60
ZEROS                : 41
[                    : 18 29
]                    : 18 29
error                : 
{                    : 57
}                    : 57

Nonterminals, with rules where they appear

ACCESS               : 17 23
ASSIGNMENT           : 9
BLOCK_STATEMENT      : 5
CONDITION            : 58 59 60
CONST_ID             : 16 18 24 61
CONST_VALUE          : 21
EXPRESSION           : 11 12 13 14 15 19 20 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 41 42 43 45 46 50 51 51 52 52 53 53 54 54 55 55 56 56 62 62 63 63 63
FOR_STATEMENT        : 8
IF_STATEMENT         : 6
INSTRUCTION          : 2 3 58 59 59 60 61
INSTRUCTIONS         : 1 2 57
KEYWORD              : 10
LEFT_ASSIGNMENT      : 11 12 13 14 15
MATRIX               : 22
RANGE                : 61
ROWS                 : 29 30
SEQUENCE             : 18 19 30 31 47
STATEMENT            : 4
VALUE                : 44
WHILE_STATEMENT      : 7
start                : 0

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . INSTRUCTIONS
    (2) INSTRUCTIONS -> . INSTRUCTIONS INSTRUCTION
    (3) INSTRUCTIONS -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    start                          shift and go to state 1
    INSTRUCTIONS                   shift and go to state 2
    INSTRUCTION                    shift and go to state 3
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 1

    (0) S' -> start .



state 2

    (1) start -> INSTRUCTIONS .
    (2) INSTRUCTIONS -> INSTRUCTIONS . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    $end            reduce using rule 1 (start -> INSTRUCTIONS .)
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTION                    shift and go to state 23
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 3

    (3) INSTRUCTIONS -> INSTRUCTION .

    {               reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    IF              reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    WHILE           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    FOR             reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    PRINT           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    BREAK           reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    CONTINUE        reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    RETURN          reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    ID              reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    $end            reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)
    }               reduce using rule 3 (INSTRUCTIONS -> INSTRUCTION .)


state 4

    (4) INSTRUCTION -> STATEMENT . ;

    ;               shift and go to state 24


state 5

    (5) INSTRUCTION -> BLOCK_STATEMENT .

    {               reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    IF              reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    WHILE           reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    FOR             reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    PRINT           reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    BREAK           reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    CONTINUE        reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    RETURN          reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    ID              reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    $end            reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    }               reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)
    ELSE            reduce using rule 5 (INSTRUCTION -> BLOCK_STATEMENT .)


state 6

    (6) INSTRUCTION -> IF_STATEMENT .

    {               reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    IF              reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    WHILE           reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    FOR             reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    PRINT           reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    BREAK           reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    CONTINUE        reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    RETURN          reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    ID              reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    $end            reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    }               reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)
    ELSE            reduce using rule 6 (INSTRUCTION -> IF_STATEMENT .)


state 7

    (7) INSTRUCTION -> WHILE_STATEMENT .

    {               reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    IF              reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    WHILE           reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    FOR             reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    PRINT           reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    BREAK           reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    CONTINUE        reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    RETURN          reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    ID              reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    $end            reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    }               reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)
    ELSE            reduce using rule 7 (INSTRUCTION -> WHILE_STATEMENT .)


state 8

    (8) INSTRUCTION -> FOR_STATEMENT .

    {               reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    IF              reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    WHILE           reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    FOR             reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    PRINT           reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    BREAK           reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    CONTINUE        reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    RETURN          reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    ID              reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    $end            reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    }               reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)
    ELSE            reduce using rule 8 (INSTRUCTION -> FOR_STATEMENT .)


state 9

    (9) STATEMENT -> ASSIGNMENT .

    ;               reduce using rule 9 (STATEMENT -> ASSIGNMENT .)


state 10

    (10) STATEMENT -> KEYWORD .

    ;               reduce using rule 10 (STATEMENT -> KEYWORD .)


state 11

    (57) BLOCK_STATEMENT -> { . INSTRUCTIONS }
    (2) INSTRUCTIONS -> . INSTRUCTIONS INSTRUCTION
    (3) INSTRUCTIONS -> . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTIONS                   shift and go to state 25
    INSTRUCTION                    shift and go to state 3
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 12

    (58) IF_STATEMENT -> IF . ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> IF . ( CONDITION ) INSTRUCTION ELSE INSTRUCTION

    (               shift and go to state 26


state 13

    (60) WHILE_STATEMENT -> WHILE . ( CONDITION ) INSTRUCTION

    (               shift and go to state 27


state 14

    (61) FOR_STATEMENT -> FOR . CONST_ID = RANGE INSTRUCTION
    (28) CONST_ID -> . ID

    ID              shift and go to state 22

    CONST_ID                       shift and go to state 28

state 15

    (16) LEFT_ASSIGNMENT -> CONST_ID .
    (18) ACCESS -> CONST_ID . [ SEQUENCE ]

    =               reduce using rule 16 (LEFT_ASSIGNMENT -> CONST_ID .)
    PLUS_ASSIGN     reduce using rule 16 (LEFT_ASSIGNMENT -> CONST_ID .)
    MINUS_ASSIGN    reduce using rule 16 (LEFT_ASSIGNMENT -> CONST_ID .)
    MUL_ASSIGN      reduce using rule 16 (LEFT_ASSIGNMENT -> CONST_ID .)
    DIV_ASSIGN      reduce using rule 16 (LEFT_ASSIGNMENT -> CONST_ID .)
    [               shift and go to state 29


state 16

    (11) ASSIGNMENT -> LEFT_ASSIGNMENT . = EXPRESSION
    (12) ASSIGNMENT -> LEFT_ASSIGNMENT . PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> LEFT_ASSIGNMENT . MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> LEFT_ASSIGNMENT . MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> LEFT_ASSIGNMENT . DIV_ASSIGN EXPRESSION

    =               shift and go to state 30
    PLUS_ASSIGN     shift and go to state 31
    MINUS_ASSIGN    shift and go to state 32
    MUL_ASSIGN      shift and go to state 33
    DIV_ASSIGN      shift and go to state 34


state 17

    (47) KEYWORD -> PRINT . SEQUENCE
    (19) SEQUENCE -> . SEQUENCE , EXPRESSION
    (20) SEQUENCE -> . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    SEQUENCE                       shift and go to state 35
    EXPRESSION                     shift and go to state 36
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 18

    (48) KEYWORD -> BREAK .

    ;               reduce using rule 48 (KEYWORD -> BREAK .)


state 19

    (49) KEYWORD -> CONTINUE .

    ;               reduce using rule 49 (KEYWORD -> CONTINUE .)


state 20

    (50) KEYWORD -> RETURN . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 51
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 21

    (17) LEFT_ASSIGNMENT -> ACCESS .

    =               reduce using rule 17 (LEFT_ASSIGNMENT -> ACCESS .)
    PLUS_ASSIGN     reduce using rule 17 (LEFT_ASSIGNMENT -> ACCESS .)
    MINUS_ASSIGN    reduce using rule 17 (LEFT_ASSIGNMENT -> ACCESS .)
    MUL_ASSIGN      reduce using rule 17 (LEFT_ASSIGNMENT -> ACCESS .)
    DIV_ASSIGN      reduce using rule 17 (LEFT_ASSIGNMENT -> ACCESS .)


state 22

    (28) CONST_ID -> ID .

    [               reduce using rule 28 (CONST_ID -> ID .)
    =               reduce using rule 28 (CONST_ID -> ID .)
    PLUS_ASSIGN     reduce using rule 28 (CONST_ID -> ID .)
    MINUS_ASSIGN    reduce using rule 28 (CONST_ID -> ID .)
    MUL_ASSIGN      reduce using rule 28 (CONST_ID -> ID .)
    DIV_ASSIGN      reduce using rule 28 (CONST_ID -> ID .)
    DOT_PLUS        reduce using rule 28 (CONST_ID -> ID .)
    DOT_MINUS       reduce using rule 28 (CONST_ID -> ID .)
    DOT_MUL         reduce using rule 28 (CONST_ID -> ID .)
    DOT_DIV         reduce using rule 28 (CONST_ID -> ID .)
    +               reduce using rule 28 (CONST_ID -> ID .)
    -               reduce using rule 28 (CONST_ID -> ID .)
    *               reduce using rule 28 (CONST_ID -> ID .)
    /               reduce using rule 28 (CONST_ID -> ID .)
    '               reduce using rule 28 (CONST_ID -> ID .)
    ,               reduce using rule 28 (CONST_ID -> ID .)
    ;               reduce using rule 28 (CONST_ID -> ID .)
    <               reduce using rule 28 (CONST_ID -> ID .)
    >               reduce using rule 28 (CONST_ID -> ID .)
    EQ              reduce using rule 28 (CONST_ID -> ID .)
    NEQ             reduce using rule 28 (CONST_ID -> ID .)
    GEQ             reduce using rule 28 (CONST_ID -> ID .)
    LEQ             reduce using rule 28 (CONST_ID -> ID .)
    ]               reduce using rule 28 (CONST_ID -> ID .)
    )               reduce using rule 28 (CONST_ID -> ID .)
    :               reduce using rule 28 (CONST_ID -> ID .)
    {               reduce using rule 28 (CONST_ID -> ID .)
    IF              reduce using rule 28 (CONST_ID -> ID .)
    WHILE           reduce using rule 28 (CONST_ID -> ID .)
    FOR             reduce using rule 28 (CONST_ID -> ID .)
    PRINT           reduce using rule 28 (CONST_ID -> ID .)
    BREAK           reduce using rule 28 (CONST_ID -> ID .)
    CONTINUE        reduce using rule 28 (CONST_ID -> ID .)
    RETURN          reduce using rule 28 (CONST_ID -> ID .)
    ID              reduce using rule 28 (CONST_ID -> ID .)


state 23

    (2) INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .

    {               reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    IF              reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    WHILE           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    FOR             reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    PRINT           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    BREAK           reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    CONTINUE        reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    RETURN          reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    ID              reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    $end            reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)
    }               reduce using rule 2 (INSTRUCTIONS -> INSTRUCTIONS INSTRUCTION .)


state 24

    (4) INSTRUCTION -> STATEMENT ; .

    {               reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    IF              reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    WHILE           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    FOR             reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    PRINT           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    BREAK           reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    CONTINUE        reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    RETURN          reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    ID              reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    $end            reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    }               reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)
    ELSE            reduce using rule 4 (INSTRUCTION -> STATEMENT ; .)


state 25

    (57) BLOCK_STATEMENT -> { INSTRUCTIONS . }
    (2) INSTRUCTIONS -> INSTRUCTIONS . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    }               shift and go to state 52
    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTION                    shift and go to state 23
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 26

    (58) IF_STATEMENT -> IF ( . CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> IF ( . CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (51) CONDITION -> . EXPRESSION < EXPRESSION
    (52) CONDITION -> . EXPRESSION > EXPRESSION
    (53) CONDITION -> . EXPRESSION EQ EXPRESSION
    (54) CONDITION -> . EXPRESSION NEQ EXPRESSION
    (55) CONDITION -> . EXPRESSION GEQ EXPRESSION
    (56) CONDITION -> . EXPRESSION LEQ EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    CONDITION                      shift and go to state 53
    EXPRESSION                     shift and go to state 54
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 27

    (60) WHILE_STATEMENT -> WHILE ( . CONDITION ) INSTRUCTION
    (51) CONDITION -> . EXPRESSION < EXPRESSION
    (52) CONDITION -> . EXPRESSION > EXPRESSION
    (53) CONDITION -> . EXPRESSION EQ EXPRESSION
    (54) CONDITION -> . EXPRESSION NEQ EXPRESSION
    (55) CONDITION -> . EXPRESSION GEQ EXPRESSION
    (56) CONDITION -> . EXPRESSION LEQ EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    CONDITION                      shift and go to state 55
    EXPRESSION                     shift and go to state 54
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 28

    (61) FOR_STATEMENT -> FOR CONST_ID . = RANGE INSTRUCTION

    =               shift and go to state 56


state 29

    (18) ACCESS -> CONST_ID [ . SEQUENCE ]
    (19) SEQUENCE -> . SEQUENCE , EXPRESSION
    (20) SEQUENCE -> . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    CONST_ID                       shift and go to state 46
    SEQUENCE                       shift and go to state 57
    EXPRESSION                     shift and go to state 36
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45

state 30

    (11) ASSIGNMENT -> LEFT_ASSIGNMENT = . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 58
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 31

    (12) ASSIGNMENT -> LEFT_ASSIGNMENT PLUS_ASSIGN . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 59
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 32

    (13) ASSIGNMENT -> LEFT_ASSIGNMENT MINUS_ASSIGN . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 60
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 33

    (14) ASSIGNMENT -> LEFT_ASSIGNMENT MUL_ASSIGN . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 61
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 34

    (15) ASSIGNMENT -> LEFT_ASSIGNMENT DIV_ASSIGN . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 62
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 35

    (47) KEYWORD -> PRINT SEQUENCE .
    (19) SEQUENCE -> SEQUENCE . , EXPRESSION

    ;               reduce using rule 47 (KEYWORD -> PRINT SEQUENCE .)
    ,               shift and go to state 63


state 36

    (20) SEQUENCE -> EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ,               reduce using rule 20 (SEQUENCE -> EXPRESSION .)
    ;               reduce using rule 20 (SEQUENCE -> EXPRESSION .)
    ]               reduce using rule 20 (SEQUENCE -> EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 37

    (46) EXPRESSION -> - . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 73
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 38

    (40) EXPRESSION -> EYE . ( EXPRESSION )

    (               shift and go to state 74


state 39

    (45) EXPRESSION -> ( . EXPRESSION )
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 75
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 40

    (41) EXPRESSION -> ZEROS . ( EXPRESSION )

    (               shift and go to state 76


state 41

    (42) EXPRESSION -> ONES . ( EXPRESSION )

    (               shift and go to state 77


state 42

    (44) EXPRESSION -> VALUE .

    DOT_PLUS        reduce using rule 44 (EXPRESSION -> VALUE .)
    DOT_MINUS       reduce using rule 44 (EXPRESSION -> VALUE .)
    DOT_MUL         reduce using rule 44 (EXPRESSION -> VALUE .)
    DOT_DIV         reduce using rule 44 (EXPRESSION -> VALUE .)
    +               reduce using rule 44 (EXPRESSION -> VALUE .)
    -               reduce using rule 44 (EXPRESSION -> VALUE .)
    *               reduce using rule 44 (EXPRESSION -> VALUE .)
    /               reduce using rule 44 (EXPRESSION -> VALUE .)
    '               reduce using rule 44 (EXPRESSION -> VALUE .)
    ,               reduce using rule 44 (EXPRESSION -> VALUE .)
    ;               reduce using rule 44 (EXPRESSION -> VALUE .)
    <               reduce using rule 44 (EXPRESSION -> VALUE .)
    >               reduce using rule 44 (EXPRESSION -> VALUE .)
    EQ              reduce using rule 44 (EXPRESSION -> VALUE .)
    NEQ             reduce using rule 44 (EXPRESSION -> VALUE .)
    GEQ             reduce using rule 44 (EXPRESSION -> VALUE .)
    LEQ             reduce using rule 44 (EXPRESSION -> VALUE .)
    ]               reduce using rule 44 (EXPRESSION -> VALUE .)
    )               reduce using rule 44 (EXPRESSION -> VALUE .)
    :               reduce using rule 44 (EXPRESSION -> VALUE .)
    {               reduce using rule 44 (EXPRESSION -> VALUE .)
    IF              reduce using rule 44 (EXPRESSION -> VALUE .)
    WHILE           reduce using rule 44 (EXPRESSION -> VALUE .)
    FOR             reduce using rule 44 (EXPRESSION -> VALUE .)
    PRINT           reduce using rule 44 (EXPRESSION -> VALUE .)
    BREAK           reduce using rule 44 (EXPRESSION -> VALUE .)
    CONTINUE        reduce using rule 44 (EXPRESSION -> VALUE .)
    RETURN          reduce using rule 44 (EXPRESSION -> VALUE .)
    ID              reduce using rule 44 (EXPRESSION -> VALUE .)


state 43

    (21) VALUE -> CONST_VALUE .

    DOT_PLUS        reduce using rule 21 (VALUE -> CONST_VALUE .)
    DOT_MINUS       reduce using rule 21 (VALUE -> CONST_VALUE .)
    DOT_MUL         reduce using rule 21 (VALUE -> CONST_VALUE .)
    DOT_DIV         reduce using rule 21 (VALUE -> CONST_VALUE .)
    +               reduce using rule 21 (VALUE -> CONST_VALUE .)
    -               reduce using rule 21 (VALUE -> CONST_VALUE .)
    *               reduce using rule 21 (VALUE -> CONST_VALUE .)
    /               reduce using rule 21 (VALUE -> CONST_VALUE .)
    '               reduce using rule 21 (VALUE -> CONST_VALUE .)
    ,               reduce using rule 21 (VALUE -> CONST_VALUE .)
    ;               reduce using rule 21 (VALUE -> CONST_VALUE .)
    <               reduce using rule 21 (VALUE -> CONST_VALUE .)
    >               reduce using rule 21 (VALUE -> CONST_VALUE .)
    EQ              reduce using rule 21 (VALUE -> CONST_VALUE .)
    NEQ             reduce using rule 21 (VALUE -> CONST_VALUE .)
    GEQ             reduce using rule 21 (VALUE -> CONST_VALUE .)
    LEQ             reduce using rule 21 (VALUE -> CONST_VALUE .)
    ]               reduce using rule 21 (VALUE -> CONST_VALUE .)
    )               reduce using rule 21 (VALUE -> CONST_VALUE .)
    :               reduce using rule 21 (VALUE -> CONST_VALUE .)
    {               reduce using rule 21 (VALUE -> CONST_VALUE .)
    IF              reduce using rule 21 (VALUE -> CONST_VALUE .)
    WHILE           reduce using rule 21 (VALUE -> CONST_VALUE .)
    FOR             reduce using rule 21 (VALUE -> CONST_VALUE .)
    PRINT           reduce using rule 21 (VALUE -> CONST_VALUE .)
    BREAK           reduce using rule 21 (VALUE -> CONST_VALUE .)
    CONTINUE        reduce using rule 21 (VALUE -> CONST_VALUE .)
    RETURN          reduce using rule 21 (VALUE -> CONST_VALUE .)
    ID              reduce using rule 21 (VALUE -> CONST_VALUE .)


state 44

    (22) VALUE -> MATRIX .

    DOT_PLUS        reduce using rule 22 (VALUE -> MATRIX .)
    DOT_MINUS       reduce using rule 22 (VALUE -> MATRIX .)
    DOT_MUL         reduce using rule 22 (VALUE -> MATRIX .)
    DOT_DIV         reduce using rule 22 (VALUE -> MATRIX .)
    +               reduce using rule 22 (VALUE -> MATRIX .)
    -               reduce using rule 22 (VALUE -> MATRIX .)
    *               reduce using rule 22 (VALUE -> MATRIX .)
    /               reduce using rule 22 (VALUE -> MATRIX .)
    '               reduce using rule 22 (VALUE -> MATRIX .)
    ,               reduce using rule 22 (VALUE -> MATRIX .)
    ;               reduce using rule 22 (VALUE -> MATRIX .)
    <               reduce using rule 22 (VALUE -> MATRIX .)
    >               reduce using rule 22 (VALUE -> MATRIX .)
    EQ              reduce using rule 22 (VALUE -> MATRIX .)
    NEQ             reduce using rule 22 (VALUE -> MATRIX .)
    GEQ             reduce using rule 22 (VALUE -> MATRIX .)
    LEQ             reduce using rule 22 (VALUE -> MATRIX .)
    ]               reduce using rule 22 (VALUE -> MATRIX .)
    )               reduce using rule 22 (VALUE -> MATRIX .)
    :               reduce using rule 22 (VALUE -> MATRIX .)
    {               reduce using rule 22 (VALUE -> MATRIX .)
    IF              reduce using rule 22 (VALUE -> MATRIX .)
    WHILE           reduce using rule 22 (VALUE -> MATRIX .)
    FOR             reduce using rule 22 (VALUE -> MATRIX .)
    PRINT           reduce using rule 22 (VALUE -> MATRIX .)
    BREAK           reduce using rule 22 (VALUE -> MATRIX .)
    CONTINUE        reduce using rule 22 (VALUE -> MATRIX .)
    RETURN          reduce using rule 22 (VALUE -> MATRIX .)
    ID              reduce using rule 22 (VALUE -> MATRIX .)


state 45

    (23) VALUE -> ACCESS .

    DOT_PLUS        reduce using rule 23 (VALUE -> ACCESS .)
    DOT_MINUS       reduce using rule 23 (VALUE -> ACCESS .)
    DOT_MUL         reduce using rule 23 (VALUE -> ACCESS .)
    DOT_DIV         reduce using rule 23 (VALUE -> ACCESS .)
    +               reduce using rule 23 (VALUE -> ACCESS .)
    -               reduce using rule 23 (VALUE -> ACCESS .)
    *               reduce using rule 23 (VALUE -> ACCESS .)
    /               reduce using rule 23 (VALUE -> ACCESS .)
    '               reduce using rule 23 (VALUE -> ACCESS .)
    ,               reduce using rule 23 (VALUE -> ACCESS .)
    ;               reduce using rule 23 (VALUE -> ACCESS .)
    <               reduce using rule 23 (VALUE -> ACCESS .)
    >               reduce using rule 23 (VALUE -> ACCESS .)
    EQ              reduce using rule 23 (VALUE -> ACCESS .)
    NEQ             reduce using rule 23 (VALUE -> ACCESS .)
    GEQ             reduce using rule 23 (VALUE -> ACCESS .)
    LEQ             reduce using rule 23 (VALUE -> ACCESS .)
    ]               reduce using rule 23 (VALUE -> ACCESS .)
    )               reduce using rule 23 (VALUE -> ACCESS .)
    :               reduce using rule 23 (VALUE -> ACCESS .)
    {               reduce using rule 23 (VALUE -> ACCESS .)
    IF              reduce using rule 23 (VALUE -> ACCESS .)
    WHILE           reduce using rule 23 (VALUE -> ACCESS .)
    FOR             reduce using rule 23 (VALUE -> ACCESS .)
    PRINT           reduce using rule 23 (VALUE -> ACCESS .)
    BREAK           reduce using rule 23 (VALUE -> ACCESS .)
    CONTINUE        reduce using rule 23 (VALUE -> ACCESS .)
    RETURN          reduce using rule 23 (VALUE -> ACCESS .)
    ID              reduce using rule 23 (VALUE -> ACCESS .)


state 46

    (24) VALUE -> CONST_ID .
    (18) ACCESS -> CONST_ID . [ SEQUENCE ]

    DOT_PLUS        reduce using rule 24 (VALUE -> CONST_ID .)
    DOT_MINUS       reduce using rule 24 (VALUE -> CONST_ID .)
    DOT_MUL         reduce using rule 24 (VALUE -> CONST_ID .)
    DOT_DIV         reduce using rule 24 (VALUE -> CONST_ID .)
    +               reduce using rule 24 (VALUE -> CONST_ID .)
    -               reduce using rule 24 (VALUE -> CONST_ID .)
    *               reduce using rule 24 (VALUE -> CONST_ID .)
    /               reduce using rule 24 (VALUE -> CONST_ID .)
    '               reduce using rule 24 (VALUE -> CONST_ID .)
    ,               reduce using rule 24 (VALUE -> CONST_ID .)
    ;               reduce using rule 24 (VALUE -> CONST_ID .)
    <               reduce using rule 24 (VALUE -> CONST_ID .)
    >               reduce using rule 24 (VALUE -> CONST_ID .)
    EQ              reduce using rule 24 (VALUE -> CONST_ID .)
    NEQ             reduce using rule 24 (VALUE -> CONST_ID .)
    GEQ             reduce using rule 24 (VALUE -> CONST_ID .)
    LEQ             reduce using rule 24 (VALUE -> CONST_ID .)
    ]               reduce using rule 24 (VALUE -> CONST_ID .)
    )               reduce using rule 24 (VALUE -> CONST_ID .)
    :               reduce using rule 24 (VALUE -> CONST_ID .)
    {               reduce using rule 24 (VALUE -> CONST_ID .)
    IF              reduce using rule 24 (VALUE -> CONST_ID .)
    WHILE           reduce using rule 24 (VALUE -> CONST_ID .)
    FOR             reduce using rule 24 (VALUE -> CONST_ID .)
    PRINT           reduce using rule 24 (VALUE -> CONST_ID .)
    BREAK           reduce using rule 24 (VALUE -> CONST_ID .)
    CONTINUE        reduce using rule 24 (VALUE -> CONST_ID .)
    RETURN          reduce using rule 24 (VALUE -> CONST_ID .)
    ID              reduce using rule 24 (VALUE -> CONST_ID .)
    [               shift and go to state 29


state 47

    (25) CONST_VALUE -> FLOAT .

    DOT_PLUS        reduce using rule 25 (CONST_VALUE -> FLOAT .)
    DOT_MINUS       reduce using rule 25 (CONST_VALUE -> FLOAT .)
    DOT_MUL         reduce using rule 25 (CONST_VALUE -> FLOAT .)
    DOT_DIV         reduce using rule 25 (CONST_VALUE -> FLOAT .)
    +               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    -               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    *               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    /               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    '               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    ,               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    ;               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    <               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    >               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    EQ              reduce using rule 25 (CONST_VALUE -> FLOAT .)
    NEQ             reduce using rule 25 (CONST_VALUE -> FLOAT .)
    GEQ             reduce using rule 25 (CONST_VALUE -> FLOAT .)
    LEQ             reduce using rule 25 (CONST_VALUE -> FLOAT .)
    ]               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    )               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    :               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    {               reduce using rule 25 (CONST_VALUE -> FLOAT .)
    IF              reduce using rule 25 (CONST_VALUE -> FLOAT .)
    WHILE           reduce using rule 25 (CONST_VALUE -> FLOAT .)
    FOR             reduce using rule 25 (CONST_VALUE -> FLOAT .)
    PRINT           reduce using rule 25 (CONST_VALUE -> FLOAT .)
    BREAK           reduce using rule 25 (CONST_VALUE -> FLOAT .)
    CONTINUE        reduce using rule 25 (CONST_VALUE -> FLOAT .)
    RETURN          reduce using rule 25 (CONST_VALUE -> FLOAT .)
    ID              reduce using rule 25 (CONST_VALUE -> FLOAT .)


state 48

    (26) CONST_VALUE -> INT .

    DOT_PLUS        reduce using rule 26 (CONST_VALUE -> INT .)
    DOT_MINUS       reduce using rule 26 (CONST_VALUE -> INT .)
    DOT_MUL         reduce using rule 26 (CONST_VALUE -> INT .)
    DOT_DIV         reduce using rule 26 (CONST_VALUE -> INT .)
    +               reduce using rule 26 (CONST_VALUE -> INT .)
    -               reduce using rule 26 (CONST_VALUE -> INT .)
    *               reduce using rule 26 (CONST_VALUE -> INT .)
    /               reduce using rule 26 (CONST_VALUE -> INT .)
    '               reduce using rule 26 (CONST_VALUE -> INT .)
    ,               reduce using rule 26 (CONST_VALUE -> INT .)
    ;               reduce using rule 26 (CONST_VALUE -> INT .)
    <               reduce using rule 26 (CONST_VALUE -> INT .)
    >               reduce using rule 26 (CONST_VALUE -> INT .)
    EQ              reduce using rule 26 (CONST_VALUE -> INT .)
    NEQ             reduce using rule 26 (CONST_VALUE -> INT .)
    GEQ             reduce using rule 26 (CONST_VALUE -> INT .)
    LEQ             reduce using rule 26 (CONST_VALUE -> INT .)
    ]               reduce using rule 26 (CONST_VALUE -> INT .)
    )               reduce using rule 26 (CONST_VALUE -> INT .)
    :               reduce using rule 26 (CONST_VALUE -> INT .)
    {               reduce using rule 26 (CONST_VALUE -> INT .)
    IF              reduce using rule 26 (CONST_VALUE -> INT .)
    WHILE           reduce using rule 26 (CONST_VALUE -> INT .)
    FOR             reduce using rule 26 (CONST_VALUE -> INT .)
    PRINT           reduce using rule 26 (CONST_VALUE -> INT .)
    BREAK           reduce using rule 26 (CONST_VALUE -> INT .)
    CONTINUE        reduce using rule 26 (CONST_VALUE -> INT .)
    RETURN          reduce using rule 26 (CONST_VALUE -> INT .)
    ID              reduce using rule 26 (CONST_VALUE -> INT .)


state 49

    (27) CONST_VALUE -> STRING .

    DOT_PLUS        reduce using rule 27 (CONST_VALUE -> STRING .)
    DOT_MINUS       reduce using rule 27 (CONST_VALUE -> STRING .)
    DOT_MUL         reduce using rule 27 (CONST_VALUE -> STRING .)
    DOT_DIV         reduce using rule 27 (CONST_VALUE -> STRING .)
    +               reduce using rule 27 (CONST_VALUE -> STRING .)
    -               reduce using rule 27 (CONST_VALUE -> STRING .)
    *               reduce using rule 27 (CONST_VALUE -> STRING .)
    /               reduce using rule 27 (CONST_VALUE -> STRING .)
    '               reduce using rule 27 (CONST_VALUE -> STRING .)
    ,               reduce using rule 27 (CONST_VALUE -> STRING .)
    ;               reduce using rule 27 (CONST_VALUE -> STRING .)
    <               reduce using rule 27 (CONST_VALUE -> STRING .)
    >               reduce using rule 27 (CONST_VALUE -> STRING .)
    EQ              reduce using rule 27 (CONST_VALUE -> STRING .)
    NEQ             reduce using rule 27 (CONST_VALUE -> STRING .)
    GEQ             reduce using rule 27 (CONST_VALUE -> STRING .)
    LEQ             reduce using rule 27 (CONST_VALUE -> STRING .)
    ]               reduce using rule 27 (CONST_VALUE -> STRING .)
    )               reduce using rule 27 (CONST_VALUE -> STRING .)
    :               reduce using rule 27 (CONST_VALUE -> STRING .)
    {               reduce using rule 27 (CONST_VALUE -> STRING .)
    IF              reduce using rule 27 (CONST_VALUE -> STRING .)
    WHILE           reduce using rule 27 (CONST_VALUE -> STRING .)
    FOR             reduce using rule 27 (CONST_VALUE -> STRING .)
    PRINT           reduce using rule 27 (CONST_VALUE -> STRING .)
    BREAK           reduce using rule 27 (CONST_VALUE -> STRING .)
    CONTINUE        reduce using rule 27 (CONST_VALUE -> STRING .)
    RETURN          reduce using rule 27 (CONST_VALUE -> STRING .)
    ID              reduce using rule 27 (CONST_VALUE -> STRING .)


state 50

    (29) MATRIX -> [ . ROWS ]
    (30) ROWS -> . ROWS ; SEQUENCE
    (31) ROWS -> . SEQUENCE
    (19) SEQUENCE -> . SEQUENCE , EXPRESSION
    (20) SEQUENCE -> . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    ROWS                           shift and go to state 78
    SEQUENCE                       shift and go to state 79
    EXPRESSION                     shift and go to state 36
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 51

    (50) KEYWORD -> RETURN EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 50 (KEYWORD -> RETURN EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 52

    (57) BLOCK_STATEMENT -> { INSTRUCTIONS } .

    {               reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    IF              reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    WHILE           reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    FOR             reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    PRINT           reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    BREAK           reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    CONTINUE        reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    RETURN          reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    ID              reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    $end            reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    }               reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)
    ELSE            reduce using rule 57 (BLOCK_STATEMENT -> { INSTRUCTIONS } .)


state 53

    (58) IF_STATEMENT -> IF ( CONDITION . ) INSTRUCTION
    (59) IF_STATEMENT -> IF ( CONDITION . ) INSTRUCTION ELSE INSTRUCTION

    )               shift and go to state 80


state 54

    (51) CONDITION -> EXPRESSION . < EXPRESSION
    (52) CONDITION -> EXPRESSION . > EXPRESSION
    (53) CONDITION -> EXPRESSION . EQ EXPRESSION
    (54) CONDITION -> EXPRESSION . NEQ EXPRESSION
    (55) CONDITION -> EXPRESSION . GEQ EXPRESSION
    (56) CONDITION -> EXPRESSION . LEQ EXPRESSION
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    <               shift and go to state 81
    >               shift and go to state 82
    EQ              shift and go to state 83
    NEQ             shift and go to state 84
    GEQ             shift and go to state 85
    LEQ             shift and go to state 86
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 55

    (60) WHILE_STATEMENT -> WHILE ( CONDITION . ) INSTRUCTION

    )               shift and go to state 87


state 56

    (61) FOR_STATEMENT -> FOR CONST_ID = . RANGE INSTRUCTION
    (62) RANGE -> . EXPRESSION : EXPRESSION
    (63) RANGE -> . EXPRESSION : EXPRESSION : EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    CONST_ID                       shift and go to state 46
    RANGE                          shift and go to state 88
    EXPRESSION                     shift and go to state 89
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45

state 57

    (18) ACCESS -> CONST_ID [ SEQUENCE . ]
    (19) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               shift and go to state 90
    ,               shift and go to state 63


state 58

    (11) ASSIGNMENT -> LEFT_ASSIGNMENT = EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 11 (ASSIGNMENT -> LEFT_ASSIGNMENT = EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 59

    (12) ASSIGNMENT -> LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 12 (ASSIGNMENT -> LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 60

    (13) ASSIGNMENT -> LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 13 (ASSIGNMENT -> LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 61

    (14) ASSIGNMENT -> LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 14 (ASSIGNMENT -> LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 62

    (15) ASSIGNMENT -> LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ;               reduce using rule 15 (ASSIGNMENT -> LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 63

    (19) SEQUENCE -> SEQUENCE , . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 91
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 64

    (32) EXPRESSION -> EXPRESSION DOT_PLUS . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 92
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 65

    (33) EXPRESSION -> EXPRESSION DOT_MINUS . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 93
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 66

    (34) EXPRESSION -> EXPRESSION DOT_MUL . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 94
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 67

    (35) EXPRESSION -> EXPRESSION DOT_DIV . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 95
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 68

    (36) EXPRESSION -> EXPRESSION + . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 96
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 69

    (37) EXPRESSION -> EXPRESSION - . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 97
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 70

    (38) EXPRESSION -> EXPRESSION * . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 98
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 71

    (39) EXPRESSION -> EXPRESSION / . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 99
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 72

    (43) EXPRESSION -> EXPRESSION ' .

    DOT_PLUS        reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    DOT_MINUS       reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    DOT_MUL         reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    DOT_DIV         reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    +               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    -               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    *               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    /               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    '               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    ,               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    ;               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    <               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    >               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    EQ              reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    NEQ             reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    GEQ             reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    LEQ             reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    ]               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    )               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    :               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    {               reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    IF              reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    WHILE           reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    FOR             reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    PRINT           reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    BREAK           reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    CONTINUE        reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    RETURN          reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)
    ID              reduce using rule 43 (EXPRESSION -> EXPRESSION ' .)


state 73

    (46) EXPRESSION -> - EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    DOT_MINUS       reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    DOT_MUL         reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    DOT_DIV         reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    +               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    -               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    *               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    /               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    '               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    ,               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    ;               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    <               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    >               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    EQ              reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    NEQ             reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    GEQ             reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    LEQ             reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    ]               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    )               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    :               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    {               reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    IF              reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    WHILE           reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    FOR             reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    PRINT           reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    BREAK           reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    CONTINUE        reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    RETURN          reduce using rule 46 (EXPRESSION -> - EXPRESSION .)
    ID              reduce using rule 46 (EXPRESSION -> - EXPRESSION .)

  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! DOT_MUL         [ shift and go to state 66 ]
  ! DOT_DIV         [ shift and go to state 67 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 71 ]
  ! '               [ shift and go to state 72 ]


state 74

    (40) EXPRESSION -> EYE ( . EXPRESSION )
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 100
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 75

    (45) EXPRESSION -> ( EXPRESSION . )
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               shift and go to state 101
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 76

    (41) EXPRESSION -> ZEROS ( . EXPRESSION )
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 102
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 77

    (42) EXPRESSION -> ONES ( . EXPRESSION )
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 103
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 78

    (29) MATRIX -> [ ROWS . ]
    (30) ROWS -> ROWS . ; SEQUENCE

    ]               shift and go to state 104
    ;               shift and go to state 105


state 79

    (31) ROWS -> SEQUENCE .
    (19) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               reduce using rule 31 (ROWS -> SEQUENCE .)
    ;               reduce using rule 31 (ROWS -> SEQUENCE .)
    ,               shift and go to state 63


state 80

    (58) IF_STATEMENT -> IF ( CONDITION ) . INSTRUCTION
    (59) IF_STATEMENT -> IF ( CONDITION ) . INSTRUCTION ELSE INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTION                    shift and go to state 106
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 81

    (51) CONDITION -> EXPRESSION < . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 107
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 82

    (52) CONDITION -> EXPRESSION > . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 108
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 83

    (53) CONDITION -> EXPRESSION EQ . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 109
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 84

    (54) CONDITION -> EXPRESSION NEQ . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 110
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 85

    (55) CONDITION -> EXPRESSION GEQ . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 111
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 86

    (56) CONDITION -> EXPRESSION LEQ . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 112
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 87

    (60) WHILE_STATEMENT -> WHILE ( CONDITION ) . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTION                    shift and go to state 113
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 88

    (61) FOR_STATEMENT -> FOR CONST_ID = RANGE . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    CONST_ID                       shift and go to state 15
    INSTRUCTION                    shift and go to state 114
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 89

    (62) RANGE -> EXPRESSION . : EXPRESSION
    (63) RANGE -> EXPRESSION . : EXPRESSION : EXPRESSION
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    :               shift and go to state 115
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 90

    (18) ACCESS -> CONST_ID [ SEQUENCE ] .

    =               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    PLUS_ASSIGN     reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    MINUS_ASSIGN    reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    MUL_ASSIGN      reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    DIV_ASSIGN      reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    DOT_PLUS        reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    DOT_MINUS       reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    DOT_MUL         reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    DOT_DIV         reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    +               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    -               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    *               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    /               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    '               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    ,               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    ;               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    <               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    >               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    EQ              reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    NEQ             reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    GEQ             reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    LEQ             reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    ]               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    )               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    :               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    {               reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    IF              reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    WHILE           reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    FOR             reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    PRINT           reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    BREAK           reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    CONTINUE        reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    RETURN          reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)
    ID              reduce using rule 18 (ACCESS -> CONST_ID [ SEQUENCE ] .)


state 91

    (19) SEQUENCE -> SEQUENCE , EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    ,               reduce using rule 19 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    ;               reduce using rule 19 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    ]               reduce using rule 19 (SEQUENCE -> SEQUENCE , EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 92

    (32) EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    DOT_MINUS       reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    +               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    -               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    ,               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    ;               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    <               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    >               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    EQ              reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    NEQ             reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    GEQ             reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    LEQ             reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    ]               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    )               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    :               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    {               reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    IF              reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    WHILE           reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    FOR             reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    PRINT           reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    BREAK           reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    CONTINUE        reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    RETURN          reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    ID              reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .)
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72

  ! DOT_MUL         [ reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .) ]
  ! DOT_DIV         [ reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .) ]
  ! *               [ reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .) ]
  ! /               [ reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .) ]
  ! '               [ reduce using rule 32 (EXPRESSION -> EXPRESSION DOT_PLUS EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]


state 93

    (33) EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    DOT_MINUS       reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    +               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    -               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    ,               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    ;               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    <               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    >               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    EQ              reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    NEQ             reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    GEQ             reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    LEQ             reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    ]               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    )               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    :               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    {               reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    IF              reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    WHILE           reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    FOR             reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    PRINT           reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    BREAK           reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    CONTINUE        reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    RETURN          reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    ID              reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .)
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72

  ! DOT_MUL         [ reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .) ]
  ! DOT_DIV         [ reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .) ]
  ! *               [ reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .) ]
  ! /               [ reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .) ]
  ! '               [ reduce using rule 33 (EXPRESSION -> EXPRESSION DOT_MINUS EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]


state 94

    (34) EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    DOT_MINUS       reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    DOT_MUL         reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    DOT_DIV         reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    +               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    -               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    *               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    /               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    ,               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    ;               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    <               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    >               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    EQ              reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    NEQ             reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    GEQ             reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    LEQ             reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    ]               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    )               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    :               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    {               reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    IF              reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    WHILE           reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    FOR             reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    PRINT           reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    BREAK           reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    CONTINUE        reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    RETURN          reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    ID              reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .)
    '               shift and go to state 72

  ! '               [ reduce using rule 34 (EXPRESSION -> EXPRESSION DOT_MUL EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! DOT_MUL         [ shift and go to state 66 ]
  ! DOT_DIV         [ shift and go to state 67 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 71 ]


state 95

    (35) EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    DOT_MINUS       reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    DOT_MUL         reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    DOT_DIV         reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    +               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    -               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    *               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    /               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    ,               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    ;               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    <               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    >               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    EQ              reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    NEQ             reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    GEQ             reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    LEQ             reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    ]               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    )               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    :               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    {               reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    IF              reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    WHILE           reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    FOR             reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    PRINT           reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    BREAK           reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    CONTINUE        reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    RETURN          reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    ID              reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .)
    '               shift and go to state 72

  ! '               [ reduce using rule 35 (EXPRESSION -> EXPRESSION DOT_DIV EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! DOT_MUL         [ shift and go to state 66 ]
  ! DOT_DIV         [ shift and go to state 67 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 71 ]


state 96

    (36) EXPRESSION -> EXPRESSION + EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    DOT_MINUS       reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    +               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    -               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    ,               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    ;               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    <               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    >               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    EQ              reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    NEQ             reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    GEQ             reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    LEQ             reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    ]               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    )               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    :               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    {               reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    IF              reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    WHILE           reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    FOR             reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    PRINT           reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    BREAK           reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    CONTINUE        reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    RETURN          reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    ID              reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .)
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72

  ! DOT_MUL         [ reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .) ]
  ! DOT_DIV         [ reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .) ]
  ! *               [ reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .) ]
  ! /               [ reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .) ]
  ! '               [ reduce using rule 36 (EXPRESSION -> EXPRESSION + EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]


state 97

    (37) EXPRESSION -> EXPRESSION - EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    DOT_MINUS       reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    +               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    -               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    ,               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    ;               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    <               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    >               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    EQ              reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    NEQ             reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    GEQ             reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    LEQ             reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    ]               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    )               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    :               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    {               reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    IF              reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    WHILE           reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    FOR             reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    PRINT           reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    BREAK           reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    CONTINUE        reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    RETURN          reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    ID              reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .)
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72

  ! DOT_MUL         [ reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .) ]
  ! DOT_DIV         [ reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .) ]
  ! *               [ reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .) ]
  ! /               [ reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .) ]
  ! '               [ reduce using rule 37 (EXPRESSION -> EXPRESSION - EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]


state 98

    (38) EXPRESSION -> EXPRESSION * EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    DOT_MINUS       reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    DOT_MUL         reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    DOT_DIV         reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    +               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    -               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    *               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    /               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    ,               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    ;               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    <               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    >               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    EQ              reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    NEQ             reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    GEQ             reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    LEQ             reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    ]               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    )               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    :               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    {               reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    IF              reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    WHILE           reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    FOR             reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    PRINT           reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    BREAK           reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    CONTINUE        reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    RETURN          reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    ID              reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .)
    '               shift and go to state 72

  ! '               [ reduce using rule 38 (EXPRESSION -> EXPRESSION * EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! DOT_MUL         [ shift and go to state 66 ]
  ! DOT_DIV         [ shift and go to state 67 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 71 ]


state 99

    (39) EXPRESSION -> EXPRESSION / EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    DOT_PLUS        reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    DOT_MINUS       reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    DOT_MUL         reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    DOT_DIV         reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    +               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    -               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    *               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    /               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    ,               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    ;               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    <               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    >               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    EQ              reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    NEQ             reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    GEQ             reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    LEQ             reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    ]               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    )               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    :               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    {               reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    IF              reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    WHILE           reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    FOR             reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    PRINT           reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    BREAK           reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    CONTINUE        reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    RETURN          reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    ID              reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .)
    '               shift and go to state 72

  ! '               [ reduce using rule 39 (EXPRESSION -> EXPRESSION / EXPRESSION .) ]
  ! DOT_PLUS        [ shift and go to state 64 ]
  ! DOT_MINUS       [ shift and go to state 65 ]
  ! DOT_MUL         [ shift and go to state 66 ]
  ! DOT_DIV         [ shift and go to state 67 ]
  ! +               [ shift and go to state 68 ]
  ! -               [ shift and go to state 69 ]
  ! *               [ shift and go to state 70 ]
  ! /               [ shift and go to state 71 ]


state 100

    (40) EXPRESSION -> EYE ( EXPRESSION . )
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               shift and go to state 116
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 101

    (45) EXPRESSION -> ( EXPRESSION ) .

    DOT_PLUS        reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    DOT_MINUS       reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    DOT_MUL         reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    DOT_DIV         reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    +               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    -               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    *               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    /               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    '               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    ,               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    ;               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    <               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    >               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    EQ              reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    NEQ             reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    GEQ             reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    LEQ             reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    ]               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    )               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    :               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    {               reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    IF              reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    WHILE           reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    FOR             reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    PRINT           reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    BREAK           reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    CONTINUE        reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    RETURN          reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)
    ID              reduce using rule 45 (EXPRESSION -> ( EXPRESSION ) .)


state 102

    (41) EXPRESSION -> ZEROS ( EXPRESSION . )
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               shift and go to state 117
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 103

    (42) EXPRESSION -> ONES ( EXPRESSION . )
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               shift and go to state 118
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 104

    (29) MATRIX -> [ ROWS ] .

    DOT_PLUS        reduce using rule 29 (MATRIX -> [ ROWS ] .)
    DOT_MINUS       reduce using rule 29 (MATRIX -> [ ROWS ] .)
    DOT_MUL         reduce using rule 29 (MATRIX -> [ ROWS ] .)
    DOT_DIV         reduce using rule 29 (MATRIX -> [ ROWS ] .)
    +               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    -               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    *               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    /               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    '               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    ,               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    ;               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    <               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    >               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    EQ              reduce using rule 29 (MATRIX -> [ ROWS ] .)
    NEQ             reduce using rule 29 (MATRIX -> [ ROWS ] .)
    GEQ             reduce using rule 29 (MATRIX -> [ ROWS ] .)
    LEQ             reduce using rule 29 (MATRIX -> [ ROWS ] .)
    ]               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    )               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    :               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    {               reduce using rule 29 (MATRIX -> [ ROWS ] .)
    IF              reduce using rule 29 (MATRIX -> [ ROWS ] .)
    WHILE           reduce using rule 29 (MATRIX -> [ ROWS ] .)
    FOR             reduce using rule 29 (MATRIX -> [ ROWS ] .)
    PRINT           reduce using rule 29 (MATRIX -> [ ROWS ] .)
    BREAK           reduce using rule 29 (MATRIX -> [ ROWS ] .)
    CONTINUE        reduce using rule 29 (MATRIX -> [ ROWS ] .)
    RETURN          reduce using rule 29 (MATRIX -> [ ROWS ] .)
    ID              reduce using rule 29 (MATRIX -> [ ROWS ] .)


state 105

    (30) ROWS -> ROWS ; . SEQUENCE
    (19) SEQUENCE -> . SEQUENCE , EXPRESSION
    (20) SEQUENCE -> . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    SEQUENCE                       shift and go to state 119
    EXPRESSION                     shift and go to state 36
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 106

    (58) IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .
    (59) IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION . ELSE INSTRUCTION

    {               reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    IF              reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    WHILE           reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    FOR             reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    PRINT           reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    BREAK           reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    CONTINUE        reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    RETURN          reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    ID              reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    $end            reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    }               reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .)
    ELSE            shift and go to state 120

  ! ELSE            [ reduce using rule 58 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION .) ]


state 107

    (51) CONDITION -> EXPRESSION < EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 51 (CONDITION -> EXPRESSION < EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 108

    (52) CONDITION -> EXPRESSION > EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 52 (CONDITION -> EXPRESSION > EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 109

    (53) CONDITION -> EXPRESSION EQ EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 53 (CONDITION -> EXPRESSION EQ EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 110

    (54) CONDITION -> EXPRESSION NEQ EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 54 (CONDITION -> EXPRESSION NEQ EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 111

    (55) CONDITION -> EXPRESSION GEQ EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 55 (CONDITION -> EXPRESSION GEQ EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 112

    (56) CONDITION -> EXPRESSION LEQ EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    )               reduce using rule 56 (CONDITION -> EXPRESSION LEQ EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 113

    (60) WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .

    {               reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    IF              reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    WHILE           reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    FOR             reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    PRINT           reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    BREAK           reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    CONTINUE        reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    RETURN          reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    ID              reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    $end            reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    }               reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)
    ELSE            reduce using rule 60 (WHILE_STATEMENT -> WHILE ( CONDITION ) INSTRUCTION .)


state 114

    (61) FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .

    {               reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    IF              reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    WHILE           reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    FOR             reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    PRINT           reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    BREAK           reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    CONTINUE        reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    RETURN          reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    ID              reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    $end            reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    }               reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)
    ELSE            reduce using rule 61 (FOR_STATEMENT -> FOR CONST_ID = RANGE INSTRUCTION .)


state 115

    (62) RANGE -> EXPRESSION : . EXPRESSION
    (63) RANGE -> EXPRESSION : . EXPRESSION : EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 121
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 116

    (40) EXPRESSION -> EYE ( EXPRESSION ) .

    DOT_PLUS        reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    DOT_MINUS       reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    DOT_MUL         reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    DOT_DIV         reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    +               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    -               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    *               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    /               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    '               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    ,               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    ;               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    <               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    >               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    EQ              reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    NEQ             reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    GEQ             reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    LEQ             reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    ]               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    )               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    :               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    {               reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    IF              reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    WHILE           reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    FOR             reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    PRINT           reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    BREAK           reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    CONTINUE        reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    RETURN          reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)
    ID              reduce using rule 40 (EXPRESSION -> EYE ( EXPRESSION ) .)


state 117

    (41) EXPRESSION -> ZEROS ( EXPRESSION ) .

    DOT_PLUS        reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    DOT_MINUS       reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    DOT_MUL         reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    DOT_DIV         reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    +               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    -               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    *               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    /               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    '               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    ,               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    ;               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    <               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    >               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    EQ              reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    NEQ             reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    GEQ             reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    LEQ             reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    ]               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    )               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    :               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    {               reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    IF              reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    WHILE           reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    FOR             reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    PRINT           reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    BREAK           reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    CONTINUE        reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    RETURN          reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)
    ID              reduce using rule 41 (EXPRESSION -> ZEROS ( EXPRESSION ) .)


state 118

    (42) EXPRESSION -> ONES ( EXPRESSION ) .

    DOT_PLUS        reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    DOT_MINUS       reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    DOT_MUL         reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    DOT_DIV         reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    +               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    -               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    *               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    /               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    '               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    ,               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    ;               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    <               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    >               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    EQ              reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    NEQ             reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    GEQ             reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    LEQ             reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    ]               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    )               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    :               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    {               reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    IF              reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    WHILE           reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    FOR             reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    PRINT           reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    BREAK           reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    CONTINUE        reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    RETURN          reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)
    ID              reduce using rule 42 (EXPRESSION -> ONES ( EXPRESSION ) .)


state 119

    (30) ROWS -> ROWS ; SEQUENCE .
    (19) SEQUENCE -> SEQUENCE . , EXPRESSION

    ]               reduce using rule 30 (ROWS -> ROWS ; SEQUENCE .)
    ;               reduce using rule 30 (ROWS -> ROWS ; SEQUENCE .)
    ,               shift and go to state 63


state 120

    (59) IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE . INSTRUCTION
    (4) INSTRUCTION -> . STATEMENT ;
    (5) INSTRUCTION -> . BLOCK_STATEMENT
    (6) INSTRUCTION -> . IF_STATEMENT
    (7) INSTRUCTION -> . WHILE_STATEMENT
    (8) INSTRUCTION -> . FOR_STATEMENT
    (9) STATEMENT -> . ASSIGNMENT
    (10) STATEMENT -> . KEYWORD
    (57) BLOCK_STATEMENT -> . { INSTRUCTIONS }
    (58) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION
    (59) IF_STATEMENT -> . IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION
    (60) WHILE_STATEMENT -> . WHILE ( CONDITION ) INSTRUCTION
    (61) FOR_STATEMENT -> . FOR CONST_ID = RANGE INSTRUCTION
    (11) ASSIGNMENT -> . LEFT_ASSIGNMENT = EXPRESSION
    (12) ASSIGNMENT -> . LEFT_ASSIGNMENT PLUS_ASSIGN EXPRESSION
    (13) ASSIGNMENT -> . LEFT_ASSIGNMENT MINUS_ASSIGN EXPRESSION
    (14) ASSIGNMENT -> . LEFT_ASSIGNMENT MUL_ASSIGN EXPRESSION
    (15) ASSIGNMENT -> . LEFT_ASSIGNMENT DIV_ASSIGN EXPRESSION
    (47) KEYWORD -> . PRINT SEQUENCE
    (48) KEYWORD -> . BREAK
    (49) KEYWORD -> . CONTINUE
    (50) KEYWORD -> . RETURN EXPRESSION
    (16) LEFT_ASSIGNMENT -> . CONST_ID
    (17) LEFT_ASSIGNMENT -> . ACCESS
    (28) CONST_ID -> . ID
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]

    {               shift and go to state 11
    IF              shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14
    PRINT           shift and go to state 17
    BREAK           shift and go to state 18
    CONTINUE        shift and go to state 19
    RETURN          shift and go to state 20
    ID              shift and go to state 22

    INSTRUCTION                    shift and go to state 122
    STATEMENT                      shift and go to state 4
    BLOCK_STATEMENT                shift and go to state 5
    IF_STATEMENT                   shift and go to state 6
    WHILE_STATEMENT                shift and go to state 7
    FOR_STATEMENT                  shift and go to state 8
    ASSIGNMENT                     shift and go to state 9
    KEYWORD                        shift and go to state 10
    CONST_ID                       shift and go to state 15
    LEFT_ASSIGNMENT                shift and go to state 16
    ACCESS                         shift and go to state 21

state 121

    (62) RANGE -> EXPRESSION : EXPRESSION .
    (63) RANGE -> EXPRESSION : EXPRESSION . : EXPRESSION
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    {               reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    IF              reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    WHILE           reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    FOR             reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    PRINT           reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    BREAK           reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    CONTINUE        reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    RETURN          reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    ID              reduce using rule 62 (RANGE -> EXPRESSION : EXPRESSION .)
    :               shift and go to state 123
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72


state 122

    (59) IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .

    {               reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    IF              reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    WHILE           reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    FOR             reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    PRINT           reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    BREAK           reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    CONTINUE        reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    RETURN          reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    ID              reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    $end            reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    }               reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)
    ELSE            reduce using rule 59 (IF_STATEMENT -> IF ( CONDITION ) INSTRUCTION ELSE INSTRUCTION .)


state 123

    (63) RANGE -> EXPRESSION : EXPRESSION : . EXPRESSION
    (32) EXPRESSION -> . EXPRESSION DOT_PLUS EXPRESSION
    (33) EXPRESSION -> . EXPRESSION DOT_MINUS EXPRESSION
    (34) EXPRESSION -> . EXPRESSION DOT_MUL EXPRESSION
    (35) EXPRESSION -> . EXPRESSION DOT_DIV EXPRESSION
    (36) EXPRESSION -> . EXPRESSION + EXPRESSION
    (37) EXPRESSION -> . EXPRESSION - EXPRESSION
    (38) EXPRESSION -> . EXPRESSION * EXPRESSION
    (39) EXPRESSION -> . EXPRESSION / EXPRESSION
    (40) EXPRESSION -> . EYE ( EXPRESSION )
    (41) EXPRESSION -> . ZEROS ( EXPRESSION )
    (42) EXPRESSION -> . ONES ( EXPRESSION )
    (43) EXPRESSION -> . EXPRESSION '
    (44) EXPRESSION -> . VALUE
    (45) EXPRESSION -> . ( EXPRESSION )
    (46) EXPRESSION -> . - EXPRESSION
    (21) VALUE -> . CONST_VALUE
    (22) VALUE -> . MATRIX
    (23) VALUE -> . ACCESS
    (24) VALUE -> . CONST_ID
    (25) CONST_VALUE -> . FLOAT
    (26) CONST_VALUE -> . INT
    (27) CONST_VALUE -> . STRING
    (29) MATRIX -> . [ ROWS ]
    (18) ACCESS -> . CONST_ID [ SEQUENCE ]
    (28) CONST_ID -> . ID

    EYE             shift and go to state 38
    ZEROS           shift and go to state 40
    ONES            shift and go to state 41
    (               shift and go to state 39
    -               shift and go to state 37
    FLOAT           shift and go to state 47
    INT             shift and go to state 48
    STRING          shift and go to state 49
    [               shift and go to state 50
    ID              shift and go to state 22

    EXPRESSION                     shift and go to state 124
    VALUE                          shift and go to state 42
    CONST_VALUE                    shift and go to state 43
    MATRIX                         shift and go to state 44
    ACCESS                         shift and go to state 45
    CONST_ID                       shift and go to state 46

state 124

    (63) RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .
    (32) EXPRESSION -> EXPRESSION . DOT_PLUS EXPRESSION
    (33) EXPRESSION -> EXPRESSION . DOT_MINUS EXPRESSION
    (34) EXPRESSION -> EXPRESSION . DOT_MUL EXPRESSION
    (35) EXPRESSION -> EXPRESSION . DOT_DIV EXPRESSION
    (36) EXPRESSION -> EXPRESSION . + EXPRESSION
    (37) EXPRESSION -> EXPRESSION . - EXPRESSION
    (38) EXPRESSION -> EXPRESSION . * EXPRESSION
    (39) EXPRESSION -> EXPRESSION . / EXPRESSION
    (43) EXPRESSION -> EXPRESSION . '

    {               reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    IF              reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    WHILE           reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    FOR             reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    PRINT           reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    BREAK           reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    CONTINUE        reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    RETURN          reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    ID              reduce using rule 63 (RANGE -> EXPRESSION : EXPRESSION : EXPRESSION .)
    DOT_PLUS        shift and go to state 64
    DOT_MINUS       shift and go to state 65
    DOT_MUL         shift and go to state 66
    DOT_DIV         shift and go to state 67
    +               shift and go to state 68
    -               shift and go to state 69
    *               shift and go to state 70
    /               shift and go to state 71
    '               shift and go to state 72

